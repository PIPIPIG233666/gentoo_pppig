From 12c57cfb847825e673777102002e4e4f5b41c920 Mon Sep 17 00:00:00 2001
From: "Yaxun (Sam) Liu" <yaxun.liu@amd.com>
Date: Tue, 29 Oct 2019 13:13:36 -0400
Subject: [PATCH] Let clang driver support parallel jobs

Change-Id: Id2df552a0aa588c56f6622c154c8af19f560735e
(cherry picked from commit 06dc443dbc19251b513d6b5aebe0a5968f031df5)
---
 clang/include/clang/Driver/Driver.h   |   9 ++
 clang/include/clang/Driver/Job.h      |   7 ++
 clang/include/clang/Driver/Options.td |   2 +
 clang/lib/Driver/Compilation.cpp      | 126 +++++++++++++++++++++++++-
 clang/lib/Driver/Driver.cpp           |   8 +-
 clang/lib/Driver/Job.cpp              |   4 +-
 6 files changed, 149 insertions(+), 7 deletions(-)

diff --git a/clang/include/clang/Driver/Driver.h b/clang/include/clang/Driver/Driver.h
index e3e98bad9912703..23e621e47c41541 100644
--- a/clang/include/clang/Driver/Driver.h
+++ b/clang/include/clang/Driver/Driver.h
@@ -333,6 +333,9 @@ class Driver {
   /// toolchains.
   llvm::DenseMap<const ToolChain *, llvm::DenseSet<llvm::StringRef>> KnownArchs;
 
+  /// Number of parallel jobs.
+  unsigned NumParallelJobs;
+
 private:
   /// TranslateInputArgs - Create a new derived argument list from the input
   /// arguments, after applying the standard argument translations.
@@ -705,6 +708,12 @@ class Driver {
     return IsOffload ? OffloadLTOMode : LTOMode;
   }
 
+  /// Get the number of parallel jobs.
+  unsigned getNumberOfParallelJobs() const { return NumParallelJobs; }
+
+  /// Set the number of parallel jobs.
+  void setNumberOfParallelJobs(unsigned N) { NumParallelJobs = N; }
+
 private:
 
   /// Tries to load options from configuration files.
diff --git a/clang/include/clang/Driver/Job.h b/clang/include/clang/Driver/Job.h
index df9449463c53bd1..a478eea11392235 100644
--- a/clang/include/clang/Driver/Job.h
+++ b/clang/include/clang/Driver/Job.h
@@ -150,6 +150,9 @@ class Command {
   /// Information on executable run provided by OS.
   mutable std::optional<llvm::sys::ProcessStatistics> ProcStat;
 
+  /// Dependent actions
+  llvm::SmallVector<const Action *, 4> DependentActions;
+
   /// When a response file is needed, we try to put most arguments in an
   /// exclusive file, while others remains as regular command line arguments.
   /// This functions fills a vector with the regular command line arguments,
@@ -234,6 +237,10 @@ class Command {
     return ProcStat;
   }
 
+  const llvm::SmallVector<const Action *, 4> &getDependentActions() const {
+    return DependentActions;
+  }
+
 protected:
   /// Optionally print the filenames to be compiled
   void PrintFileNames() const;
diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index e04f67bdb1fa568..3f64e549fbef850 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -795,6 +795,8 @@ def Ofast : Joined<["-"], "Ofast">, Group<O_Group>, Flags<[CC1Option, FlangOptio
 def P : Flag<["-"], "P">, Flags<[CC1Option,FlangOption,FC1Option]>, Group<Preprocessor_Group>,
   HelpText<"Disable linemarker output in -E mode">,
   MarshallingInfoNegativeFlag<PreprocessorOutputOpts<"ShowLineMarkers">>;
+def parallel_jobs_EQ : Joined<["-"], "parallel-jobs=">, Flags<[NoXarchOption]>,
+  HelpText<"Number of parallel jobs">;
 def Qy : Flag<["-"], "Qy">, Flags<[CC1Option]>,
   HelpText<"Emit metadata containing compiler name and version">;
 def Qn : Flag<["-"], "Qn">, Flags<[CC1Option]>,
diff --git a/clang/lib/Driver/Compilation.cpp b/clang/lib/Driver/Compilation.cpp
index ad077d5bbfa69ab..33cde8f3f600245 100644
--- a/clang/lib/Driver/Compilation.cpp
+++ b/clang/lib/Driver/Compilation.cpp
@@ -15,6 +15,7 @@
 #include "clang/Driver/Options.h"
 #include "clang/Driver/ToolChain.h"
 #include "clang/Driver/Util.h"
+#include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/Option/ArgList.h"
@@ -24,8 +25,11 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/TargetParser/Triple.h"
 #include <cassert>
+#include <functional>
+#include <mutex>
 #include <string>
 #include <system_error>
+#include <thread>
 #include <utility>
 
 using namespace clang;
@@ -239,6 +243,100 @@ static bool InputsOk(const Command &C,
   return !ActionFailed(&C.getSource(), FailingCommands);
 }
 
+namespace {
+class JobScheduler {
+public:
+  enum JobState { JS_WAIT, JS_RUN, JS_DONE, JS_FAIL };
+  JobScheduler(const JobList &Jobs, size_t NJobs = 1)
+      : Jobs(Jobs), NumJobs(NJobs) {
+#if !LLVM_ENABLE_THREADS
+    NumJobs = 1;
+#endif
+    for (auto &Job : Jobs) {
+      JState[&Job] = JS_WAIT;
+      for (const auto *AI : Job.getDependentActions()) {
+        for (const auto *CI : ActToCmds[AI]) {
+          DependentCmds[&Job].push_back(CI);
+        }
+      }
+      for (const auto *CI : ActToCmds[&Job.getSource()]) {
+        DependentCmds[&Job].push_back(CI);
+      }
+      ActToCmds[&Job.getSource()].push_back(&Job);
+    }
+  }
+  /// \return true if all jobs are done. Otherwise, \p Next contains the
+  /// the next job ready to be executed if it is not null pointer. Otherwise
+  /// all jobs are running or waiting.
+  bool IsDone(const Command *&Next) {
+    std::lock_guard<std::mutex> lock(Mutex);
+    Next = nullptr;
+    unsigned Done = 0;
+    unsigned Running = 0;
+    for (auto &Cmd : Jobs) {
+      switch (JState[&Cmd]) {
+      case JS_RUN:
+        ++Running;
+        break;
+      case JS_DONE:
+      case JS_FAIL:
+        ++Done;
+        break;
+      case JS_WAIT: {
+        bool InputsReady = true;
+        for (const auto *CI : DependentCmds[&Cmd]) {
+          if (JState[CI] == JS_FAIL) {
+            JState[&Cmd] = JS_FAIL;
+            ++Done;
+            InputsReady = false;
+            break;
+          }
+          if (JState[CI] != JS_DONE) {
+            InputsReady = false;
+            break;
+          }
+        }
+        if (!Next && InputsReady) {
+          Next = &Cmd;
+        }
+        break;
+      }
+      }
+    }
+    if (Running >= NumJobs)
+      Next = nullptr;
+    return Done == Jobs.size();
+  }
+
+  void setJobState(const Command *Cmd, JobState JS) {
+    std::lock_guard<std::mutex> lock(Mutex);
+    JState[Cmd] = JS;
+  }
+
+  void launch(std::function<void()> Work) {
+#if LLVM_ENABLE_THREADS
+    if (NumJobs == 1) {
+      Work();
+      return;
+    }
+    std::thread Th(Work);
+    Th.detach();
+#else
+    Work();
+#endif
+  }
+
+private:
+  std::mutex Mutex;
+  const JobList &Jobs;
+  llvm::DenseMap<const Command *, JobState> JState;
+  llvm::DenseMap<const Action *, llvm::SmallVector<const Command *, 4>>
+      ActToCmds;
+  llvm::DenseMap<const Command *, llvm::SmallVector<const Command *, 4>>
+      DependentCmds;
+  size_t NumJobs; // Number of parallel jobs to run
+};
+} // namespace
 void Compilation::ExecuteJobs(const JobList &Jobs,
                               FailingCommandList &FailingCommands,
                               bool LogOnly) const {
@@ -246,16 +344,34 @@ void Compilation::ExecuteJobs(const JobList &Jobs,
   // inputs on the command line even one of them failed.
   // In all but CLMode, execute all the jobs unless the necessary inputs for the
   // job is missing due to previous failures.
-  for (const auto &Job : Jobs) {
-    if (!InputsOk(Job, FailingCommands))
+  JobScheduler JS(Jobs, getDriver().getNumberOfParallelJobs());
+
+  const Command *Next = nullptr;
+  while (!JS.IsDone(Next)) {
+    if (!Next) {
+      std::this_thread::yield();
       continue;
-    const Command *FailingCommand = nullptr;
-    if (int Res = ExecuteCommand(Job, FailingCommand, LogOnly)) {
-      FailingCommands.push_back(std::make_pair(Res, FailingCommand));
+    }
+
+    if (!InputsOk(*Next, FailingCommands)) {
+      JS.setJobState(Next, JobScheduler::JS_FAIL);
       // Bail as soon as one command fails in cl driver mode.
       if (TheDriver.IsCLMode())
         return;
+      continue;
     }
+
+    JS.setJobState(Next, JobScheduler::JS_RUN);
+    auto Work = [&, Next]() {
+      const Command *FailingCommand = nullptr;
+      if (int Res = ExecuteCommand(*Next, FailingCommand)) {
+        JS.setJobState(Next, JobScheduler::JS_FAIL);
+        FailingCommands.push_back(std::make_pair(Res, FailingCommand));
+      } else {
+        JS.setJobState(Next, JobScheduler::JS_DONE);
+      }
+    };
+    JS.launch(Work);
   }
 }
 
diff --git a/clang/lib/Driver/Driver.cpp b/clang/lib/Driver/Driver.cpp
index bdbdad9362e1978..9444e1a429474f1 100644
--- a/clang/lib/Driver/Driver.cpp
+++ b/clang/lib/Driver/Driver.cpp
@@ -63,11 +63,13 @@
 #include "clang/Driver/InputInfo.h"
 #include "clang/Driver/Job.h"
 #include "clang/Driver/Options.h"
+#include "clang/Driver/OptionUtils.h"
 #include "clang/Driver/Phases.h"
 #include "clang/Driver/SanitizerArgs.h"
 #include "clang/Driver/Tool.h"
 #include "clang/Driver/ToolChain.h"
 #include "clang/Driver/Types.h"
+#include "clang/Driver/Util.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/StringExtras.h"
@@ -206,7 +208,8 @@ Driver::Driver(StringRef ClangExecutable, StringRef TargetTriple,
       CCPrintProcessStats(false), CCPrintInternalStats(false),
       TargetTriple(TargetTriple), Saver(Alloc), PrependArg(nullptr),
       CheckInputsExist(true), ProbePrecompiled(true),
-      SuppressMissingInputWarning(false) {
+      SuppressMissingInputWarning(false), NumParallelJobs(1) {
+
   // Provide a sane fallback if no VFS is specified.
   if (!this->VFS)
     this->VFS = llvm::vfs::getRealFileSystem();
@@ -1429,6 +1432,9 @@ Compilation *Driver::BuildCompilation(ArrayRef<const char *> ArgList) {
     }
   }
 
+  setNumberOfParallelJobs(
+      getLastArgIntValue(Args, options::OPT_parallel_jobs_EQ, 1, Diags));
+
   std::unique_ptr<llvm::opt::InputArgList> UArgs =
       std::make_unique<InputArgList>(std::move(Args));
 
diff --git a/clang/lib/Driver/Job.cpp b/clang/lib/Driver/Job.cpp
index 203400440f9f61f..46214c9656a7d31 100644
--- a/clang/lib/Driver/Job.cpp
+++ b/clang/lib/Driver/Job.cpp
@@ -43,9 +43,11 @@ Command::Command(const Action &Source, const Tool &Creator,
                  const char *PrependArg)
     : Source(Source), Creator(Creator), ResponseSupport(ResponseSupport),
       Executable(Executable), PrependArg(PrependArg), Arguments(Arguments) {
-  for (const auto &II : Inputs)
+  for (const auto &II : Inputs) {
     if (II.isFilename())
       InputInfoList.push_back(II);
+    DependentActions.push_back(II.getAction());
+  }
   for (const auto &II : Outputs)
     if (II.isFilename())
       OutputFilenames.push_back(II.getFilename());
